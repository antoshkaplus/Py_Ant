from math import *import financeimport numtechfrom numtech.proper_integration import Integraldef mean(arr,r=None):  res = None   if r == None:    res = sum(arr)/float(len(arr))   else:     res = sum(map(lambda x,y:x*y,arr,r))  return res  def cov(arr1,arr2,r=None):  """  arr1 : 1-st var set  arr2 : 2-nd var set  r    : matrix, where r[i][j] = Pr(v1=arr[i],v2=arr[j])       : if no r then len(arr1) = len(arr2), r - diagonal matrix  """  n1 = len(arr1)  n2 = len(arr2)  if r != None:    m1 = mean(arr1,tuple(sum(r[i][j] for j in range(n2)) for i in range(n1)))    m2 = mean(arr2,tuple(sum(r[i][j] for i in range(n1)) for j in range(n2)))    res = sum(arr1[i]*arr2[j]*r[i][j] for i in range(n1) for j in range(n2))    res -= m1*m2  else:    m1 = mean(arr1)    m2 = mean(arr2)    res = sum(arr1[i]*arr2[i] for i in range(n1))/float(n1) - m1*m2  return resdef cor(arr1,arr2,r=None):  c = cov(arr1,arr2,r)  n1 = len(arr1)  n2 = len(arr2)  sd1 = sd(arr1,tuple(sum(r[i][j] for j in range(n2)) for i in range(n1)) if r != None else r)  sd2 = sd(arr2,tuple(sum(r[i][j] for i in range(n1)) for j in range(n2)) if r != None else r)  return c/(sd1*sd2)    def sd(arr,r=None):  m = mean(arr,r)  f = lambda x: x-m  pr = lambda x,y: x*y  c = map(f,arr)  c = map(pr,c,c)  res = None  if r == None:    res = sum(c)/len(arr)  else:    res = sum(map(pr,c,r))  return res**(0.5)  def dnorm(x,mean=0.,sd=1.):  return exp(-(x-mean)*(x-mean)/(2.*sd*sd))/(sd*sqrt(2.*pi))  def pnorm((lower,upper),mean=0.,sd=1.):    res = None  if mean != 0. or sd != 1.:    a = 1./sd    b = -float(mean)/sd    if lower != None: lower = a*lower+b    if upper != None: upper = a*upper+b    res = pnorm((lower,upper))  else:      if lower < -6: lower = None    if upper > 6: upper = None    func = lambda *x: Integral(dnorm,x).solve_by_simpson(1.e-6)[0]    if lower == None:      if upper == None:        res = 1.      elif upper <= 0.:        res = 0.5-func(upper,0.)      else: # upper > 0        res = 0.5+func(0.,upper)    elif upper == None:      if lower <= 0.:        res = func(lower,0.)+0.5      else: # lower > 0.        res = 0.5-func(0.,lower)             else: # upper != None and lower != None      res = func(lower,upper)  return res    def qnorm(x,mean=0.,sd=1.):  """ using adaptive Simpson method with Lyness condition """  d = dnorm  def sr(a,b):    """ Simpson rule """    c = (a+b)/2.    h3 = abs(b-a)/6.    return h3*(d(a) + 4.*d(c) + d(b))  epsG = 1.e-6  step = 1.  aG = -6.  bG = aG+step  stack = [(aG,bG,sr(aG,bG),epsG)]  JG = x  pG = aG  while JG > epsG:    if stack == []:      aG = bG      bG += 1.        stack.append((aG,bG,sr(aG,bG),epsG))    else:      a,b,J0,eps = stack.pop()      c = (a+b)/2.      left = sr(a,c)      right = sr(c,b)      J1 = left+right      #print abs(J1-J0)      if abs(J1-J0) <= eps:        if JG >= J1:          JG -= J1          pG = b        elif JG >= left:          JG -= left          pG = c          stack.append((c,b,right,eps/2))        else:           stack.append((a,c,left,eps/2))       else:        stack.append((c,b,right,eps/2))            stack.append((a,c,left,eps/2))    return (pG+float(mean)/sd)*sd    if __name__ == "__main__":  pass  """  print pnorm((None,0.))  print pnorm((None,1.))  print pnorm((-1,1))  print pnorm((None,0.),mean=2,sd=3)  """  """  print qnorm(0.5)        			# 0  print qnorm(0.5,mean=1) 			# 1  print qnorm(0.5,mean=1,sd=2)  # 1  print qnorm(0.5,mean=2,sd=2)  # 2  print qnorm(0.5,mean=2,sd=4)  # 2  print qnorm(0.25,mean=2,sd=2) # 0.6510205  print qnorm(0.333)            # -0.4316442  print qnorm(0.333,sd=3)       # -1.294933  print qnorm(0.75,mean=5,sd=2) # 6.34898  """