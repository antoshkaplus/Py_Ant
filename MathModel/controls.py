import Tkinter as tkimport timeimport numpy as npfrom const import *class MotionButtons(tk.Frame):  def __init__(self,master,obs,**options):    """    obs - element where send Motion events    """    tk.Frame.__init__(self,master,**options)    self.obs = obs        b1 = tk.Button(self,width=10,command=self.b1_handler)    b2 = tk.Button(self,width=10,text="Stop",command=self.b2_handler)        b1.pack()    b2.pack()        self.b1,self.b2 = b1,b2    self.set_motion(STOP)      def set_motion(self,motion):    b1,b2 = self.b1,self.b2    if motion == START:      b1.config(text="Pause")      b2.config(state=tk.NORMAL)       self.b1m = PAUSE         elif motion == PAUSE:      b1.config(text="Further")      self.b1m = FURTHER    elif motion == FURTHER:      b1.config(text="Pause")      self.b1m = PAUSE    else: # mn == Motion.stop      b1.config(text="Start")      self.b1m = START      b2.config(state=tk.DISABLED)    def b1_handler(self):     self.obs.set_motion(self.b1m)        def b2_handler(self):    #if self.b2["state"] != tk.DISABLED:    self.obs.set_motion(STOP)      # separatorclass DataLabels(tk.Frame):  def __init__(self,master,texts,vars,data_width,**options):    tk.Frame.__init__(self,master,**options)        text_width = max(map(len,texts))    for i in range(len(texts)):      row = tk.Frame(self)      tk.Label(row,text=texts[i],width=text_width).pack(side=tk.LEFT)      tk.Label(row,textvariable=vars[i],width=data_width).pack(side=tk.RIGHT)      row.pack()        class DataEntries(tk.Frame):  def __init__(self,master,texts,vars,data_width,**options):    tk.Frame.__init__(self,master,**options)         ents = []     text_width = max(map(len,texts))    for i in range(len(texts)):      row = tk.Frame(self)      tk.Label(row,text=texts[i],width=text_width).pack(side=tk.LEFT)      ents.append(tk.Entry(row,textvariable=vars[i],width=data_width))      ents[-1].pack(side=tk.RIGHT)      row.pack()    self.ents = ents      def set_state(self,state):    for ent in self.ents:      ent.config(state=state)        # separator class MainMenu(tk.Menu):  def __init__(self,master,elements,**options):    tk.Menu.__init__(self,master,**options)    MainMenu.construct(self,elements)      @staticmethod  def construct(parent,elements):     for label,motion in elements:      if label == "-":        parent.add_separator()         elif type(motion) is list:        submenu = tk.Menu(parent,tearoff=False)        MainMenu.construct(submenu,motion)        parent.add_cascade(label=label,menu=submenu)      else:         parent.add_command(label=label,command=motion)          # separatorclass Timer():  """  tm_sc = time_scale  sc_tm_past = scaled time past  tm_st = time start  """   def __init__(self,tm_sc=1.):    self.tm_st = None    self.sc_tm_past = None    self.tm_sc = tm_sc    def set_time_scale(self,val):              if self.tm_st == None:      self.tm_sc = val    else:      new_tm_st = time.time()      self.sc_tm_past += (new_tm_st-self.tm_st)*self.tm_sc      self.tm_st = new_tm_st      self.tm_sc = val        def start(self,tm_sc=None):    if tm_sc != None:      self.set_time_scale(tm_sc)    self.tm_st = time.time()    self.sc_tm_past = 0.      def stop(self):      self.tm_st = None    self.sc_tm_past = 0.  def further(self):    self.tm_st = time.time()      def pause(self):      self.sc_tm_past += (time.time()-self.tm_st)*self.tm_sc    self.tm_st = None     def get_time(self):    return self.sc_tm_past + ((time.time()-self.tm_st)*self.tm_sc if self.tm_st != None else 0.)    # separator class Formula:  def __init__(self,L1,m,c0,S):    """    L1 - length of the beam    m - mass of the bob    c0 - stiffness of the spring    S - outer pulse    """    self.formula = lambda t: (2.*S/(L1*np.sqrt(m*c0)) *                               np.sin(np.sqrt(c0/m)*t/2.))    self.max = lambda: S/(np.sqrt(c0*m*L1/2.))    self.L1 = L1    def get_val(self,t):    x = self.formula(t)     return x if x <= self.max() else None          def corrupt(self):    return True if self.L1 <= 2. else False    # separator     