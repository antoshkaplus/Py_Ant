import numpy as npimport matplotlib.pyplot as pltnp.seterr(all="raise")def sumt_method(func,func_grad,constrs,x0,r0,c,e):  def min(f,f_gr,x0,e):    x = x0.copy()    y = y0 = f(x)    while True:       alpha = 2.      while ((not all(map(lambda constr: constr(x-alpha*f_gr(x)) > 0,constrs))) or             (f(x-alpha*f_gr(x)) >= y0)): alpha /= 2.      x -= alpha*f_gr(x)      y0,y = y,f(x)       if y0-y <= e: break    return x,y  n_iter = 0  q = [x0]  x = x0  r = r0  while True:    x,y = min(lambda x: func(x,r),lambda x: func_grad(x,r),x,e*0.1)     n_iter+=1    q.append(x)    if r0 != r and y0-y < e: break            r /= c     y0 = y      return x,func(x,r),n_iter,qif __name__ == "__main__":            def test1():    func = lambda x: 1./3.*((x[0]+1.)**3)+x[1]    constrs = [lambda x: x[0]-1.,               lambda x: x[1]]    func_grad = lambda x: np.array([(x[0]+1.)**2,1.])    inv_constrs_grad = lambda x: np.array([-1./((x[0]-1.)**2),                                           -1./(x[1]**2)])    func_main = lambda x,r: func(x)+r*sum([1./c(x) for c in constrs])                                            func_main_grad = lambda x,r: func_grad(x) + r*inv_constrs_grad(x)        e = 0.1**3    r0 = 1.    c = 10.    x0 = np.array([2.,1.])    return func_main,func_main_grad,constrs,x0,r0,c,e      xb = [1./2.,2.5]  yb = [-1./2.,1.5]    func = lambda x: 1./3.*((x[0]+1.)**3)+x[1]  X = np.arange(xb[0],xb[1],0.01)  Y = np.arange(yb[0],yb[1],0.01)      Z = np.array([np.array([func([x,y]) for x in X]) for y in Y])      plt.contour(X,Y,Z)                   x,y,n_iter,q = sumt_method(*test1())  print x,y,n_iter    X,Y = zip(*q)  plt.plot(X,Y,'r')  plt.plot(X,Y,'ro')    plt.plot([1,1],[yb[0],yb[1]],"g")  plt.plot([xb[0],xb[1]],[0,0],"g")      plt.show()                                                                  